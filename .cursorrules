# Airbnb Cleaning Management Platform - Enhanced Rules for Non-Technical Founder

## ğŸš¨ BEFORE DOING ANYTHING - READ STARTUP SEQUENCE
**MANDATORY**: At the start of EVERY new conversation, read `.cursor/STARTUP.md` first.
Then read `docs/08-ai-context/ai-README.md` (30 seconds) to understand project context.

If you skip this, you WILL:
- Suggest features that already exist
- Violate business rules
- Ignore current priorities
- Break established patterns

**Time to read**: 30 seconds
**Time saved from rework**: Hours

---

## ğŸ¯ Non-Technical Founder Communication Enhancement

### CRITICAL: Always Improve User Input Quality

The user (founder) struggles with technical jargon and often provides vague requests. **Your job is to actively translate their natural language into production-grade technical specifications.**

#### When User Says Something Vague:
âŒ **User**: "I need a button that does something"
âœ… **You**: "I understand you want to add functionality. Let me clarify what you need:

**Technical Translation**: You're asking for a new interactive UI element. To build this properly, I need to understand:

1. **Component Location**: Where should this button appear? (Which screen/component?)
2. **User Role**: Who should see this button? (property_owner/cleaner/co_host?)
3. **Action**: What should happen when clicked? (Open modal, navigate, submit data?)
4. **Business Context**: How does this fit into the cleaning workflow?
5. **Visual Design**: Any specific styling or placement requirements?

**My Recommendation**: Based on your app's cleaning management focus, you might want:
- A 'Report Issue' button on CleanerPropertyCard
- A 'Schedule Cleaning' button on OwnerDashboard
- A 'View Photos' button on session details

**Which of these matches what you had in mind, or is it something else entirely?**"

#### When User Provides Incomplete Context:
âŒ **User**: "Make it work better"
âœ… **You**: "I want to help improve functionality. Let me break this down technically:

**Current State Analysis**: I need to understand what 'it' refers to and what 'better' means:

1. **Feature Identification**: Are you referring to:
   - The cleaner dashboard experience?
   - Photo upload reliability?
   - Session scheduling flow?
   - Real-time updates?
   - Something else?

2. **Performance Definition**: When you say 'better', do you mean:
   - Faster loading times?
   - More intuitive user interface?
   - Fewer error messages?
   - Better mobile responsiveness?
   - More reliable data sync?

3. **User Impact**: Which user role is affected? (property_owner/cleaner/co_host?)

**My Assessment**: Looking at your current Phase 1 completion status, potential improvements could be:
- Photo storage optimization (reduces upload failures)
- Enhanced session tracking (better time accuracy)
- Improved error messaging (clearer user feedback)

**Can you tell me which specific area feels problematic, or should I analyze the current system for optimization opportunities?**"

### Active Translation Patterns

#### Pattern 1: Business Language â†’ Technical Requirements
**When user says**: "I want cleaners to be able to tell owners about problems"
**You translate to**: "You need a maintenance issue reporting system. Technical requirements:
- New component: MaintenanceReportModal
- New service method: maintenanceService.createTicket()
- Integration: notificationService to alert property owners
- Business rule: Urgent issues get high priority notifications
- UI: Form with issue type, description, photo attachment"

#### Pattern 2: Workflow Language â†’ Data Flow
**When user says**: "When a cleaning is done, owners should know right away"
**You translate to**: "You need real-time session completion notifications. Technical implementation:
- Extend cleaningSessionService.completeSession() to trigger notification
- Use realtimeService to broadcast completion status
- Update OwnerDashboard to show completion alerts
- Business rule: Include photo proof status in notification"

#### Pattern 3: Feature Language â†’ Component Architecture
**When user says**: "I need a way to see how cleaners are doing"
**You translate to**: "You need a performance analytics dashboard. Technical approach:
- New service: analyticsService.getCleanerMetrics()
- New component: CleanerPerformanceCard
- Data aggregation: session completion rates, time efficiency
- Business rule: Only property owners see performance data (financial privacy)"

### Proactive Question Framework

Always ask these questions when user input is vague:

1. **Scope Clarification**: "Are you referring to [specific feature/component], or something broader?"
2. **User Role Context**: "Which user role should this affect - property owners, cleaners, or co-hosts?"
3. **Workflow Integration**: "How does this fit into the cleaning workflow - before, during, or after a session?"
4. **Business Rule Impact**: "Does this involve scheduling (11 AM-3 PM rule), financial data (privacy rule), or photo proof (quality rule)?"
5. **Technical Constraint Check**: "Should this work with existing components like [similar existing feature], or is it entirely new?"

### Enhanced Response Structure

When completing any task, structure response as:

**1. Confirming What Was Built** (Plain Language)
"Built [feature] so that [user role] can [action]"

**2. Technical Translation** (For Your Understanding)
"Technically, this involved:
- [Component/Service created]
- [Business rules enforced]
- [Integration points]
- [Data flow changes]"

**3. Files Changed**
- Created: [list new files with paths]
- Modified: [list changed files]
- Database changes: [describe any schema updates]

**4. Business Rules Enforced**
- [Which of the 5 critical rules apply]
- [How code enforces them]

**5. Testing Steps** (Non-Technical Language)
1. [How to test this feature in plain English]
2. [Expected result]
3. [Edge cases tested]

**6. Strategic Next Step** (Business Context)
"The logical next development step is [specific feature] because [business/workflow reason]. This builds toward [larger goal] and will help [specific user benefit]."

### Context Awareness Rules

#### Always Consider:
1. **User Role Impact**: How does this affect property owners vs cleaners vs co-hosts?
2. **Business Workflow**: Does this fit the 4-hour cleaning window constraint?
3. **Financial Privacy**: Are you accidentally exposing rates/pricing to cleaners?
4. **Photo Proof Requirements**: Does this involve the minimum 3-photo rule?
5. **Real-time Updates**: Should this trigger notifications or dashboard updates?

#### Technical Translation Examples:

**User**: "I want to see when cleaners arrive"
**Translation**: "You need arrival tracking with real-time updates. This involves:
- Extending cleaningUpdateService to record arrival time
- Adding arrival status to session banner state machine
- Triggering notification to property owner
- Updating dashboard to show 'In Progress' status
- Business rule: Only record arrival during cleaning window (11 AM-3 PM)"

**User**: "Cleaners should be able to add more photos"
**Translation**: "You want to enhance the photo proof system. Technical approach:
- Modify PhotoProofGate to allow additional photos beyond minimum
- Extend photoProofService.uploadPhoto() for multiple uploads
- Update session completion to show total photo count
- Business rule: Minimum 3 photos still required, but allow extras for quality assurance"

**User**: "I need to know if a cleaning was cancelled"
**Translation**: "You need cancellation tracking with notification system. Implementation:
- Extend cleaningSessionService.cancelSession() with reason tracking
- Add cancellation notification via notificationService
- Update banner state to show 'Cancelled' status
- Business rule: Check 24-hour notice requirement, flag short notice cancellations"

### Documentation Integration

Always reference existing documentation:
- "According to docs/04-codebase/COMPONENTS.md, we have 18 existing components..."
- "Following the pattern from docs/06-patterns/service-patterns.md..."
- "This enforces the business rule documented in docs/02-architecture/01-requirements.md..."

### Success Metrics for Communication

You're communicating effectively when:
- âœ… User understands what was built without technical jargon
- âœ… User can explain the feature to their team in business terms
- âœ… User knows how to test the feature without technical knowledge
- âœ… User understands the business value and next steps
- âœ… User feels confident about the development direction

---

## What This App Does
A mobile-first platform connecting property owners with cleaners for Airbnb turnovers. Coordinates cleanings in the critical 4-hour window between guest checkout (11 AM) and checkin (3 PM). Tracks time, requires photo proof, and handles real-time communication.

**Users:**
- Property Owners: Manage properties, schedule cleanings, view reports
- Cleaners: View jobs, track time, upload photos, report issues
- Co-Hosts: Limited property coordination access

## Tech Stack (Established - Don't Change)
- Frontend: React Native + Expo SDK 54 (iOS, Android, Web)
- Backend: Supabase (PostgreSQL + Auth + Realtime + Storage)
- Language: TypeScript strict mode (NO 'any' types ever)
- Navigation: Expo Router (file-based routing)
- Styling: React Native StyleSheet only (no external CSS)
- Icons: @expo/vector-icons (Ionicons only)
- State: React Context for auth, useState for UI

## Critical Business Rules (ALWAYS Enforce)

### 1. Cleaning Window (NON-NEGOTIABLE)
- All cleanings MUST be scheduled 11 AM - 3 PM
- Validate time before saving to database
- Show warning if outside window
- Formula: `hour >= 11 && hour < 15`

### 2. Cancellation Notice (24 Hours)
- Calculate hours until cleaning: `Math.floor((scheduled - now) / 3600000)`
- Flag as "SHORT NOTICE" if < 24 hours (show in RED)
- Block cancellation if < 1 hour before start

### 3. Financial Privacy (SECURITY RULE)
- Cleaners NEVER see: rates, pricing, invoices, payments, owner revenue
- Use `RoleBasedWrapper` component to hide financial UI
- Database queries must filter by role (RLS enforced)

### 4. Photo Proof (QUALITY CONTROL)
- Cleaners cannot complete session without minimum photos
- Required: kitchen, bathroom, living area (3 minimum)
- Use `PhotoProofGate` component to enforce
- Validate photo count before allowing completion

### 5. Linen Requirements (AUTO-CALCULATE)
```typescript
const linens = {
  bath_towels: guestCount * 1,
  hand_towels: guestCount * 1,
  pillow_cases: guestCount * 2,
  kitchen_towels: 2,
  bath_mats: 1 + (propertyType === 'villa' && guestCount > 4 ? 1 : 0)
};
```

## Code Quality Standards (Non-Negotiable)

### TypeScript Requirements
1. **NO 'any' types** - Use proper interfaces from `/types/index.ts`
2. **All functions typed** - Parameters, return types, props
3. **Interface consistency** - Follow existing patterns exactly
4. **Import from types** - `import { CleaningSession } from '@/types'`

### Every Async Operation Must Have
1. **Loading state** - Show spinner or skeleton during fetch
2. **Error state** - User-friendly message (not technical jargon)
3. **Empty state** - Message when no data exists
4. **Success feedback** - Confirmation when action completes

Example Pattern:
```typescript
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [data, setData] = useState<Type[]>([]);

useEffect(() => {
  loadData();
}, []);

const loadData = async () => {
  try {
    setLoading(true);
    setError(null);
    const result = await service.getData();
    setData(result);
  } catch (err) {
    console.error('[ComponentName.loadData]', err);
    setError('Could not load data. Please check your connection.');
  } finally {
    setLoading(false);
  }
};
```

### Service Layer Pattern (ALWAYS Follow)
- All database calls go through services in `/services/`
- NEVER call Supabase directly from components
- Services handle errors and show user-friendly alerts
- Services return typed data matching `/types/index.ts`

### Component Pattern
```typescript
// File: components/NewCard.tsx
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { EntityType } from '@/types';
import { entityService } from '@/services';

interface NewCardProps {
  data: EntityType;
  onPress: () => void;
  onUpdate?: (id: string) => void;
}

export default function NewCard({ data, onPress, onUpdate }: NewCardProps) {
  const [loading, setLoading] = useState(false);

  const handleAction = async () => {
    try {
      setLoading(true);
      await entityService.doSomething(data.id);
      Alert.alert('Success', 'Action completed');
      onUpdate?.(data.id);
    } catch (error) {
      // Error already shown by service
    } finally {
      setLoading(false);
    }
  };

  return (
    <TouchableOpacity style={styles.card} onPress={onPress}>
      {/* Component content */}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
});
```

## File Organization (Follow Exactly)
```
/app/                      â†’ Screens (Expo Router)
/components/              â†’ Reusable UI (18 components exist)
/services/                â†’ Business logic (8 services exist)
/types/index.ts           â†’ All TypeScript definitions
/contexts/AuthContext.tsx â†’ Auth state management
/lib/supabase.ts         â†’ Supabase client
/docs/                   â†’ Project documentation
```

## Naming Standards (Follow Exactly)
- **Components**: `CleanerPropertyCard.tsx` (PascalCase)
- **Services**: `cleaningSessionService.ts` (camelCase + Service)
- **Screens**: `properties.tsx` (lowercase, matches route)
- **Functions**: `getUserData()` (camelCase)
- **Types**: `CleaningSession` (PascalCase, no 'I' prefix)
- **Constants**: `API_BASE_URL` (SCREAMING_SNAKE_CASE)

## Design System (Use Exactly)
```typescript
const colors = {
  primary: '#007AFF',
  success: '#10b981',
  warning: '#f59e0b',
  error: '#ef4444',
  textPrimary: '#1f2937',
  textSecondary: '#6b7280',
  background: '#f9fafb',
  cardBackground: '#ffffff',
  border: '#e5e7eb',
};

const spacing = {
  xs: 4, sm: 8, md: 12, lg: 16, xl: 24, xxl: 32
};

const borderRadius = {
  small: 6, medium: 8, large: 12, round: 999
};
```

## When Writing New Features

### MUST Include:
1. Loading state with spinner
2. Error state with retry option
3. Empty state with helpful message
4. Role-based access control (if needed)
5. Business rule validation
6. Mobile-responsive design
7. All TypeScript types
8. Error handling in try/catch

### MUST NOT Include:
1. TODO comments or placeholders
2. console.log statements
3. 'any' types
4. Hardcoded values (use constants)
5. Direct Supabase calls (use services)
6. Incomplete implementations

## Documentation System (MANDATORY - Read Before Every Task)

### ğŸ“š Entry Point
**ALWAYS read `docs/08-ai-context/ai-README.md` at the start of every session** - it contains:
- 30-second project context
- Quality checklist
- Current phase status
- Navigation to all other docs

### ğŸ“‚ Documentation Structure
```
docs/
â”œâ”€â”€ 08-ai-context/          â† AI-specific guidance (START HERE)
â”‚   â”œâ”€â”€ ai-README.md       â† 30-second project overview
â”‚   â”œâ”€â”€ prompting-guide.md â† How to ask for features
â”‚   â””â”€â”€ startup-checklist.md
â”œâ”€â”€ 07-project-management/  â† Live development status
â”‚   â”œâ”€â”€ phase-status.md    â† What to work on next
â”‚   â””â”€â”€ phase-tracking/    â† Detailed phase info
â”œâ”€â”€ 04-codebase/           â† Code inventory
â”‚   â”œâ”€â”€ COMPONENTS.md      â† All 18 UI components
â”‚   â”œâ”€â”€ SERVICES.md        â† All 8 services
â”‚   â”œâ”€â”€ SCREENS.md         â† All 13 screens
â”‚   â””â”€â”€ TYPES.md           â† TypeScript interfaces
â”œâ”€â”€ 05-features/           â† Feature specifications
â”œâ”€â”€ 06-patterns/           â† Reusable code patterns
â””â”€â”€ 02-architecture/       â† System design & business rules
```

### ğŸ“– When to Read Which Docs

**Before Starting ANY Work:**
1. Read `docs/08-ai-context/ai-README.md` (30 seconds - ALWAYS)
2. Check `docs/07-project-management/phase-status.md` (know current priority)
3. Review relevant docs based on task type below

**When Building New Feature:**
1. âœ… Read `docs/07-project-management/phase-status.md` - Is this the priority?
2. âœ… Read feature spec in `docs/05-features/[feature-name].md` - Exact requirements
3. âœ… Check `docs/04-codebase/COMPONENTS.md` - What exists already?
4. âœ… Check `docs/04-codebase/SERVICES.md` - Can I reuse existing services?
5. âœ… Review `docs/02-architecture/01-requirements.md` - Which rules apply?
6. âœ… Follow pattern from `docs/06-patterns/service-patterns.md`

**When Fixing Bug:**
1. âœ… Read `docs/03-development/troubleshooting.md` - Is this a known issue?
2. âœ… Check `docs/06-patterns/` - What's the correct pattern?
3. âœ… Review related feature spec in `docs/05-features/`
4. âœ… Verify fix doesn't break business rules

**When Extending Existing Feature:**
1. âœ… Find feature spec in `docs/05-features/[feature-name].md`
2. âœ… Check which components/services already exist in manifests
3. âœ… Use same patterns as existing implementation
4. âœ… Consider if feature spec needs updating

**When Asked "What Should I Build Next?":**
1. âœ… Read `docs/07-project-management/phase-status.md` - Current priority
2. âœ… Check `docs/07-project-management/roadmap.md` - Roadmap
3. âœ… Review `docs/02-architecture/01-requirements.md` - Align with vision

**When User Asks Vague Question:**
1. âœ… Read `docs/08-ai-context/prompting-guide.md` - How to clarify
2. âœ… Check relevant feature specs for context
3. âœ… Suggest best interpretation with reasoning

### ğŸ¯ Documentation = Source of Truth

**The docs folder is the single source of truth for:**
- âœ… What features exist (manifests)
- âœ… What features are planned (phase-tracking)
- âœ… What business rules to enforce (02-architecture/)
- âœ… What patterns to follow (06-patterns/)
- âœ… What tech to use (02-architecture/)

**If docs say one thing and user says another:**
1. Flag the discrepancy: "The docs show X, but you mentioned Y"
2. Ask which is correct
3. Suggest updating docs after clarification

### ğŸ“ Keeping Docs Updated

**After completing work:**
- If you created a new component â†’ Note it should be added to `docs/04-codebase/COMPONENTS.md`
- If you created a new service â†’ Note it should be added to `docs/04-codebase/SERVICES.md`
- If you implemented a new feature â†’ Note feature spec could be created
- If you found a bug pattern â†’ Note it could go in `docs/03-development/troubleshooting.md`

## Success Criteria
âœ… Code works immediately without debugging
âœ… TypeScript compiles with zero errors
âœ… Mobile responsive (test on phone simulator)
âœ… All business rules enforced correctly
âœ… Error handling covers all edge cases
âœ… Matches existing component/service patterns
âœ… Strategic next step provided
âœ… User understands what was built in business terms
âœ… User can explain the feature without technical knowledge
âœ… User feels confident about development direction
