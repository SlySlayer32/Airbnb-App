---
alwaysApply: true
---
# Architecture & Data Flow

## ğŸ—ï¸ Big Picture Architecture

### Three-Layer System
```
UI Layer (Components)
    â†“ calls
Service Layer (Business Logic)
    â†“ queries
Database Layer (Supabase)
```

**Critical Rule**: Components NEVER call Supabase directly - always through services

### Component Organization Strategy
Files named by role + feature pattern:
- `CleanerPropertyCard.tsx` - What cleaners see
- `OwnerPropertyCard.tsx` - What owners see
- `RoleBasedWrapper.tsx` - Access control utility

**Why**: Instantly know who uses what, easier maintenance, clear permissions

### Service Boundaries
Each service owns one domain:
```
propertyService      â†’ Properties CRUD, filtering
cleaningSessionService â†’ Session lifecycle, scheduling
cleaningUpdateService â†’ Real-time progress updates
notificationService   â†’ Cross-user alerts
realtimeService       â†’ Supabase subscription management
photoProofService     â†’ Photo validation, storage
bannerStateService    â†’ Dashboard banner logic
```

**Integration Point**: Services can call each other (e.g., cleaningSessionService â†’ notificationService)

## ğŸ”„ Critical Data Flows

### 1. Session Lifecycle Flow
```
Schedule Created â†’ cleaningSessionService.createSession()
                â†’ Notification sent to cleaner
                â†’ Real-time subscription updates dashboard
Cleaner Arrives â†’ cleaningUpdateService.recordArrival()
                â†’ Banner state changes to "in progress"
                â†’ Owner dashboard updates via realtime
Cleaner Completes â†’ PhotoProofGate enforces minimum photos
                  â†’ cleaningSessionService.completeSession()
                  â†’ Notification sent to owner
                  â†’ Historical data logged
```

### 2. Authentication Flow
```
User Login â†’ Supabase Auth
          â†’ AuthContext stores session
          â†’ Profile fetched from database
          â†’ Role-based routing (dashboard varies by role)
          â†’ Demo mode fallback if Supabase not configured
```

**Demo Mode**: App works without Supabase using mockProfiles.ts - critical for development

### 3. Real-time Updates Flow
```
Component mounts â†’ realtimeService.subscribe(table, callback)
Database changes â†’ Supabase WebSocket notification
                â†’ callback executes with new data
                â†’ Component re-renders with fresh state
Component unmounts â†’ realtimeService.unsubscribe(channel)
```

**Tables with Real-time**: cleaning_sessions, cleaning_updates, notifications

### 4. Photo Proof Flow
```
Cleaner completes tasks â†’ PhotoProofGate checks photo count
                       â†’ If < 3 photos: blocks completion, shows warning
                       â†’ If >= 3 photos: allows completion
                       â†’ Photos uploaded to Supabase Storage
                       â†’ URLs stored in cleaning_session record
                       â†’ Owner views in session history
```

## ğŸ¯ Why These Architectural Decisions

### Service Layer (vs Direct DB Calls)
- **Reusability**: Same logic across multiple screens
- **Testing**: Mock services, not database
- **Error Handling**: Centralized user-friendly messages
- **Business Rules**: One place to enforce cleaning window, photo minimums, etc.

### File-Based Routing (Expo Router)
- **Intuitive**: File path = URL path
- **Type-Safe**: Navigation params typed
- **Deep Linking**: URLs work automatically
- **SEO**: Web version gets proper routes

### Context Only for Auth (Not Redux/Zustand)
- **Simplicity**: App state is local, not global
- **Performance**: No prop drilling but minimal re-renders
- **Learning Curve**: Easier for non-technical founder to understand
- **Future-Proof**: Can add state library if needed

### TypeScript Strict Mode
- **Catch Bugs Early**: Type errors at compile time
- **Self-Documenting**: Types explain what data looks like
- **Refactor Safely**: Rename with confidence
- **Team Coordination**: Clear contracts between functions

## ğŸ”Œ External Integration Points

### Supabase Integration
**Environment Required**:
```bash
EXPO_PUBLIC_SUPABASE_URL=https://xyz.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbG...
```

**Graceful Degradation**: If env vars missing â†’ demo mode with mock data

### Platform-Specific Code
```typescript
import { Platform } from 'react-native';

if (Platform.OS === 'web') {
  // Web-specific storage
} else {
  // Native AsyncStorage
}
```

**Location**: `utils/supabase.ts` - handles storage adapter per platform

## ğŸ§ª Testing Strategy (Current State)
- **Manual Testing**: Primary method (founder runs `npm start`, tests features)
- **Type Checking**: `npm run lint` (TypeScript compiler)
- **Jest Setup**: Exists but minimal coverage (__tests__/AuthContext.test.tsx)

**Future**: Expand test coverage as team grows

## ğŸ“Š State Management Patterns

### When to Use What
```
Local useState        â†’ UI state (loading, selected item, form inputs)
AuthContext          â†’ User session, profile, demo mode flag
Supabase Realtime    â†’ Multi-user live data (sessions, notifications)
Props                â†’ Parent â†’ Child data flow
Callbacks            â†’ Child â†’ Parent events
```

### Anti-Patterns to Avoid
âŒ Prop drilling more than 2 levels â†’ use Context or refactor
âŒ Setting state in render â†’ use useEffect
âŒ Multiple sources of truth â†’ pick one (state or props, not both)
âŒ Large objects in useState â†’ break into multiple states

## ğŸ” Security Architecture

### Row Level Security (RLS)
Every database query filtered by:
- User role (from profile.role)
- Team membership (from team_members table)
- Property ownership (from properties.owner_id)

**Enforcement**: Server-side in Supabase, UI uses RoleBasedWrapper for display only

### Financial Data Privacy
```typescript
// In components
<RoleBasedWrapper allowedRoles={['property_owner', 'co_host']}>
  <InvoiceCard />
</RoleBasedWrapper>

// In services
if (!['property_owner', 'co_host'].includes(profile.role)) {
  throw new Error('Insufficient permissions');
}
```

**Critical**: Cleaners NEVER see pricing, rates, invoices, or financial metrics
