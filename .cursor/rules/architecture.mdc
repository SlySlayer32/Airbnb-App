---
alwaysApply: true
---
# Architecture & Data Flow

## 🏗️ Big Picture Architecture

### Three-Layer System
```
UI Layer (Components)
    ↓ calls
Service Layer (Business Logic)
    ↓ queries
Database Layer (Supabase)
```

**Critical Rule**: Components NEVER call Supabase directly - always through services

### Component Organization Strategy
Files named by role + feature pattern:
- `CleanerPropertyCard.tsx` - What cleaners see
- `OwnerPropertyCard.tsx` - What owners see
- `RoleBasedWrapper.tsx` - Access control utility

**Why**: Instantly know who uses what, easier maintenance, clear permissions

### Service Boundaries
Each service owns one domain:
```
propertyService      → Properties CRUD, filtering
cleaningSessionService → Session lifecycle, scheduling
cleaningUpdateService → Real-time progress updates
notificationService   → Cross-user alerts
realtimeService       → Supabase subscription management
photoProofService     → Photo validation, storage
bannerStateService    → Dashboard banner logic
```

**Integration Point**: Services can call each other (e.g., cleaningSessionService → notificationService)

## 🔄 Critical Data Flows

### 1. Session Lifecycle Flow
```
Schedule Created → cleaningSessionService.createSession()
                → Notification sent to cleaner
                → Real-time subscription updates dashboard
Cleaner Arrives → cleaningUpdateService.recordArrival()
                → Banner state changes to "in progress"
                → Owner dashboard updates via realtime
Cleaner Completes → PhotoProofGate enforces minimum photos
                  → cleaningSessionService.completeSession()
                  → Notification sent to owner
                  → Historical data logged
```

### 2. Authentication Flow
```
User Login → Supabase Auth
          → AuthContext stores session
          → Profile fetched from database
          → Role-based routing (dashboard varies by role)
          → Demo mode fallback if Supabase not configured
```

**Demo Mode**: App works without Supabase using mockProfiles.ts - critical for development

### 3. Real-time Updates Flow
```
Component mounts → realtimeService.subscribe(table, callback)
Database changes → Supabase WebSocket notification
                → callback executes with new data
                → Component re-renders with fresh state
Component unmounts → realtimeService.unsubscribe(channel)
```

**Tables with Real-time**: cleaning_sessions, cleaning_updates, notifications

### 4. Photo Proof Flow
```
Cleaner completes tasks → PhotoProofGate checks photo count
                       → If < 3 photos: blocks completion, shows warning
                       → If >= 3 photos: allows completion
                       → Photos uploaded to Supabase Storage
                       → URLs stored in cleaning_session record
                       → Owner views in session history
```

## 🎯 Why These Architectural Decisions

### Service Layer (vs Direct DB Calls)
- **Reusability**: Same logic across multiple screens
- **Testing**: Mock services, not database
- **Error Handling**: Centralized user-friendly messages
- **Business Rules**: One place to enforce cleaning window, photo minimums, etc.

### File-Based Routing (Expo Router)
- **Intuitive**: File path = URL path
- **Type-Safe**: Navigation params typed
- **Deep Linking**: URLs work automatically
- **SEO**: Web version gets proper routes

### Context Only for Auth (Not Redux/Zustand)
- **Simplicity**: App state is local, not global
- **Performance**: No prop drilling but minimal re-renders
- **Learning Curve**: Easier for non-technical founder to understand
- **Future-Proof**: Can add state library if needed

### TypeScript Strict Mode
- **Catch Bugs Early**: Type errors at compile time
- **Self-Documenting**: Types explain what data looks like
- **Refactor Safely**: Rename with confidence
- **Team Coordination**: Clear contracts between functions

## 🔌 External Integration Points

### Supabase Integration
**Environment Required**:
```bash
EXPO_PUBLIC_SUPABASE_URL=https://xyz.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbG...
```

**Graceful Degradation**: If env vars missing → demo mode with mock data

### Platform-Specific Code
```typescript
import { Platform } from 'react-native';

if (Platform.OS === 'web') {
  // Web-specific storage
} else {
  // Native AsyncStorage
}
```

**Location**: `utils/supabase.ts` - handles storage adapter per platform

## 🧪 Testing Strategy (Current State)
- **Manual Testing**: Primary method (founder runs `npm start`, tests features)
- **Type Checking**: `npm run lint` (TypeScript compiler)
- **Jest Setup**: Exists but minimal coverage (__tests__/AuthContext.test.tsx)

**Future**: Expand test coverage as team grows

## 📊 State Management Patterns

### When to Use What
```
Local useState        → UI state (loading, selected item, form inputs)
AuthContext          → User session, profile, demo mode flag
Supabase Realtime    → Multi-user live data (sessions, notifications)
Props                → Parent → Child data flow
Callbacks            → Child → Parent events
```

### Anti-Patterns to Avoid
❌ Prop drilling more than 2 levels → use Context or refactor
❌ Setting state in render → use useEffect
❌ Multiple sources of truth → pick one (state or props, not both)
❌ Large objects in useState → break into multiple states

## 🔐 Security Architecture

### Row Level Security (RLS)
Every database query filtered by:
- User role (from profile.role)
- Team membership (from team_members table)
- Property ownership (from properties.owner_id)

**Enforcement**: Server-side in Supabase, UI uses RoleBasedWrapper for display only

### Financial Data Privacy
```typescript
// In components
<RoleBasedWrapper allowedRoles={['property_owner', 'co_host']}>
  <InvoiceCard />
</RoleBasedWrapper>

// In services
if (!['property_owner', 'co_host'].includes(profile.role)) {
  throw new Error('Insufficient permissions');
}
```

**Critical**: Cleaners NEVER see pricing, rates, invoices, or financial metrics
