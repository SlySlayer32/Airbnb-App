---
description: Screen development and navigation patterns
globs: ["app/**/*.tsx"]
alwaysApply: false
---

# Screen & Navigation Patterns

## File-Based Routing Structure

```
app/
  _layout.tsx           → Root layout with AuthGuard
  index.tsx            → Dashboard (role-specific content)
  properties.tsx       → Property management
  schedule.tsx         → Cleaning schedules
  team.tsx            → Team member management
  invoices.tsx        → Financial management (owner/co_host only)
  auth/
    login.tsx         → Authentication screens (modals)
```

## Navigation Patterns

```tsx
import { useRouter } from 'expo-router';

const router = useRouter();

// Navigate to screen
router.push('/properties');

// Navigate with parameters
router.push('/properties?filter=active');

// Replace current screen (no back button)
router.replace('/dashboard');

// Go back
router.back();
```

## Role-Based Screen Protection

```tsx
import RoleBasedWrapper from '@/components/RoleBasedWrapper';

// Wrap sensitive content
<RoleBasedWrapper allowedRoles={['property_owner', 'co_host']}>
  <FinancialDataComponent />
</RoleBasedWrapper>
```

## Screen Template

```tsx
import React, { useState, useEffect } from 'react';
import { View, ScrollView, StyleSheet, RefreshControl } from 'react-native';
import { useAuth } from '@/contexts/AuthContext';
import { someService } from '@/services';
import { SomeType } from '@/types';

export default function FeatureScreen() {
  const { profile } = useAuth();
  const [data, setData] = useState<SomeType[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const result = await someService.getData();
      setData(result);
    } catch (error) {
      // Error handled in service
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadData();
    setRefreshing(false);
  };

  return (
    <ScrollView 
      style={styles.container}
      refreshControl={<RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />}
    >
      {/* Screen content */}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f9fafb',
  },
});
```

## Pre-Build Checklist
- Draft a user story: “As a [role], I need to [business action] so that [business outcome].”
- List data requirements (services, types, filters) and confirm Supabase rows have RLS coverage.
- Enumerate UI states: loading, empty, success, pagination, error, permission denied.
- Plan business alerts: e.g., highlight short-notice cancellations in red, surface urgent maintenance banners.
- Decide how completion is confirmed (alerts, toasts, navigation) and how errors recover (retry, contact support).
- Outline manual test steps for role-specific verification before marking complete.

## Performance Rules

- Use FlatList for lists >10 items (not ScrollView)
- Implement RefreshControl for pull-to-refresh
- Show loading states during data fetching
- Include empty states for when no data exists

## Screen-Specific Patterns

### Dashboard Screens
- Show role-specific content
- Include quick actions
- Display recent activity
- Provide navigation to main features

### List Screens
- Implement filtering and search
- Show loading and empty states
- Include pull-to-refresh
- Use FlatList for performance

### Detail Screens
- Show comprehensive information
- Include action buttons
- Handle loading and error states
- Provide navigation back

### Form Screens
- Validate input before submission
- Show clear error messages
- Include loading states
- Provide cancel/save options

## Error Handling in Screens

```tsx
// Standard error handling pattern
const handleAction = async () => {
  try {
    setLoading(true);
    setError(null);
    
    const result = await someService.doSomething();
    
    // Success feedback
    Alert.alert('Success', 'Action completed successfully');
    
  } catch (error) {
    // Log technical details for debugging
    console.error('Action failed:', error);
    
    // Show user-friendly message
    const userMessage = error.message.includes('network') 
      ? 'Please check your internet connection'
      : 'Something went wrong. Please try again.';
    
    Alert.alert('Error', userMessage);
    setError(userMessage);
    
  } finally {
    setLoading(false);
  }
};
```

## Loading States

```tsx
// Show loading indicators
{loading && (
  <View style={styles.loadingContainer}>
    <Text style={styles.loadingText}>Loading...</Text>
  </View>
)}

// Disable buttons during loading
<TouchableOpacity 
  style={[styles.button, loading && styles.buttonDisabled]}
  onPress={handleAction}
  disabled={loading}
>
  <Text style={styles.buttonText}>
    {loading ? 'Processing...' : 'Submit'}
  </Text>
</TouchableOpacity>
```

## Empty States

```tsx
// Show when no data
{data.length === 0 && !loading && (
  <View style={styles.emptyContainer}>
    <Text style={styles.emptyTitle}>No items found</Text>
    <Text style={styles.emptySubtitle}>
      Get started by adding your first item
    </Text>
    <TouchableOpacity style={styles.emptyButton}>
      <Text style={styles.emptyButtonText}>Add Item</Text>
    </TouchableOpacity>
  </View>
)}
```